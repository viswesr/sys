// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// Generate system call table for FreeBSD from master list
// (for example, /usr/src/sys/kern/syscalls.master).
package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"regexp"
	"strings"
)

var (
	goos, goarch string
)

// cmdLine returns this programs's commandline arguments
func cmdLine() string {
	return "go run mksysnum_freebsd.go " + strings.Join(os.Args[1:], " ")
}

// buildTags returns build tags
func buildTags() string {
	return fmt.Sprintf("%s,%s", goarch, goos)
}

func checkErr(err error) {
	if err != nil {
		fmt.Fprint(os.Stderr, err.Error(), "\n")
		os.Exit(1)
	}
}

// source string and substring slice for regexp
type re struct {
	str string   // source string
	sub []string // matched sub-string
}

// Match performs regular expression match
func (r *re) Match(exp string) bool {
	r.sub = regexp.MustCompile(exp).FindStringSubmatch(r.str)
	if r.sub != nil {
		return true
	}
	return false
}

func main() {
	// Get the OS and architecture (using GOARCH_TARGET if it exists)
	goos = os.Getenv("GOOS")
	goarch = os.Getenv("GOARCH_TARGET")
	if goarch == "" {
		goarch = os.Getenv("GOARCH")
	}
	// Check if GOOS and GOARCH environment variables are defined
	if goarch == "" || goos == "" {
		fmt.Fprintf(os.Stderr, "GOARCH or GOOS not defined in environment\n")
		os.Exit(1)
	}
	// Download syscalls.master file
	resp, err := http.Get(os.Args[1])
	checkErr(err)
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	checkErr(err)

	text := ""
	s := bufio.NewScanner(strings.NewReader(string(body)))
	for s.Scan() {
		t := re{str: s.Text()}
		if t.Match(`^([0-9]+)\s+\S+\s+(?:NO)?STD\s+({ \S+\s+(\w+).*)$`) {
			num, proto := t.sub[1], t.sub[2]
			name := fmt.Sprintf("SYS_" + t.sub[3])
			name = strings.ToUpper(name)

			// There are multiple entries for enosys and nosys, so comment them out.
			nm := re{str: name}
			if nm.Match(`^SYS_E?NOSYS$`) {
				name = fmt.Sprintf("// %s", name)
			}
			if name == `SYS_SYS_EXIT` {
				name = `SYS_EXIT`
			}

			text += fmt.Sprintf("	%s = %s;  // %s\n", name, num, proto)
		}
	}
	err = s.Err()
	checkErr(err)

	fmt.Printf(template, cmdLine(), buildTags(), text)
}

const template = `// %s
// Code generated by the command above; see README.md. DO NOT EDIT.

// +build %s

package unix

const(
%s )`
